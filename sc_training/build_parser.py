# AUTOGENERATED! DO NOT EDIT! File to edit: 04_build_parser.ipynb (unless otherwise specified).

__all__ = ['count_composicion', 'count_started', 'get_expansion_time', 'list_player_upgrades']

# Internal Cell

# Import dependencies
from pathlib import Path
from pprint import pprint
from dataclasses import dataclass, astuple, field
from datetime import datetime
from typing import *
from fastcore import test as ft
from itertools import zip_longest

import pandas as pd
import numpy as np
import csv
import json

import sc2reader

from sc_training import *



# Internal Cell

# Load data files

data_path = Path(Path.cwd()/'data') \
            if Path('data').exists() else Path('../data')

with open(data_path/'unit_names.csv') as f:
    file_reader = csv.reader(f)
    unit_names = next(file_reader)

with open(data_path/'changes_names.csv') as f:
    file_reader = csv.reader(f)
    change_names = next(file_reader)

with open(data_path/'army_list.json') as f:
    race_armies = json.load(f)

with open(data_path/'buildings_list.json') as f:
    race_buildings = json.load(f)

with open(data_path/'upgrades.json') as f:
    race_upgrades = json.load(f)


# Internal Cell
def composition_df(rpl: sc2reader.resources.Replay,
                   pid: int, buildings:bool=False) -> pd.DataFrame:
    """Generates a DataFrame that stores the spawning information of each
    of a player's units

    This function lists all of the units owned by a player during a match.
    It also stores each unit's spawning_start, spawning_finish and death
    times. These times have been calculated to coincide with the match's
    duration.

    *Args*
        - rpl (sc2reader.resources.Replay)
            The match's replay object.
        - pid (int)
            The player's match id.
        - buildings (bool=False)
            Boolean indicating if the function should calculate the army or
            building units' DataFrame

    *Returns*
        - pd.DataFrame
            DataFrame with columns: Unit, started_building, enter_game_time,
            and died_time.

    """
    p_race = rpl.player[pid].play_race

    # Get the player's race list of army or building units.
    u_list = race_buildings[p_race] if buildings else race_armies[p_race]

    # Get the player's units-list.
    player_units = [(uname, u, u.id) for u in rpl.player[pid].units
                    for uname in u_list
                    if uname in u.name.lower()
                    and (('hallucinated' not in u.__dict__)
                         or ('hallucinated' in u.__dict__
                             and u.hallucinated == False))
                    and u.is_building == buildings]

    player_units_df = pd.DataFrame({
        'Unit':[uname for uname, u, id in player_units],
        'Uname': [u.name for uname, u, id in player_units],
        'UnitID':[id for uname, u, id in player_units],
        'started_building':[calc_realtime_index((u.started_at/rpl.game_fps),
                                                rpl)
                            for uname, u, id in player_units],
        'enter_game_time': [calc_realtime_index((u.finished_at/rpl.game_fps),
                                                rpl)
                            if u.finished_at != None else pd.NaT
                            for uname, u, id in player_units],
        'died_time': [calc_realtime_index((u.died_at/rpl.game_fps), rpl)
                      if u.died_at != None else pd.NaT
                      for uname, u, id in player_units]
    })

    if p_race == 'Terran' and buildings:
        # Correct double count for tech labs
        player_units_df.drop_duplicates(subset='UnitID',
                                        keep='last',
                                        inplace=True)

        # Correct misslabeling of reactors
        player_units_df.loc[player_units_df['Uname'].\
            str.contains('TechLab'), 'Unit'] = 'techlab'
        player_units_df.loc[player_units_df['Uname'].\
            str.contains('Reactor'), 'Unit'] = 'reactor'



    # Generate and return the DataFrame with info from the units.
    return player_units_df.drop(['Uname', 'UnitID'], axis=1)



# Internal Cell
def count_active_units(df: pd.DataFrame,
                       end: float, start:float = 0) -> pd.DataFrame:
    """Generates a count of units started, born (completed), and died during a
    specific period.

    This function uses a player's units' spawning start and finishing times
    and their death times to count their active units during a specific
    period. This period is defined by start and end values in seconds

    *Args*
        - df (pd.DataFrame)
            DataFrame of a player's units' start and finish spawning,
            and death times (see `composition_df` function)
        - end (float)
            End of the period
        - start (float = 0)
            Start of the period, if not defined, the function assumes it
            should count from the begining of the match

    *Returns*
        - pd.DataFrame
            DataFrame with records for all of a player's units wich were
            started, born, and died during a specific period of time.

    """


    # Gets the titles of the relevant DataFrame columns. Ignores the index
    # and the 'Units' columns.
    column_headers = df.columns[1:]

    # Gets a list of Sub-DataFrames that eliminate the rows where each of
    # the relevant columns has na values.
    dfs_no_na = [df.dropna(subset=[col_header])
                 for col_header in column_headers]

    # Takes each of the sub-DataFrames and eliminates the values that fall
    # out of the time indexes that are counted (start and end)
    states_dfs = [(state_df.loc[(state_df[header] > start)
                  & (state_df[header] <= end)]
                  if not state_df.empty else state_df)
                  for header, state_df in zip(column_headers, dfs_no_na)]

    # Counts the number of units in each sub-DataFrame.
    # i.e. Counts how many of each unit type were started, born and died
    # duringh the time limits (start, end).
    count_frames = [state_df.groupby('Unit').size() for state_df in states_dfs]

    # Organises the final DataFrame with the unit counts for the time period.
    headers = ['started', 'born', 'died']
    result_dfs = pd.DataFrame({head: count_frame
                               for head, count_frame
                               in zip(headers, count_frames)})
    result_dfs['total'] = result_dfs['born'].subtract(result_dfs['died'],
                                                      fill_value = 0)
    return result_dfs



# Internal Cell
def complete_count(compositions:list[pd.DataFrame],
                   player_race:str,
                   buildings:bool = False) -> list[dict[str, int]]:
    """
    Generate a DataFrame of a players unit count including all possible
    units for a player's race, even those that a player did not use
    during a match.

    Expands a player's simple unit count DataFrames adding columns for
    all the units a player's race affords them. Having columns for all
    units makes averaging with the results of multiple matches eassier.

    *Args*
        - compositions (list[pd.DataFrame])
            List of DataFrames containing the players' unit counts or army
            composition for different game stages or intervals.
        - player_race (str)
            The game race with which the player played the current match.
            Needed to complete the list of units or structures.
        - buildings (bool = False)
            This flag indicates if the DataFrames being constructed are of
            a player's buildings or army units.

    *Returns*
        - list[dict[str, int]]
            List of dictionaries with all the player's race's units as keys
            and the number of each unit a player had during a match as values.

    """
    unit_list = race_armies if not buildings else race_buildings
    return [{unit: int(compo[unit]) if (unit in compo)
            and not np.isnan(compo[unit]) else 0
            for unit in unit_list[player_race]}
            for compo in compositions]



# Cell
def count_composicion(rpl: sc2reader.resources.Replay,
                      pid: int, buildings:bool=False) \
                      -> list[dict[str, int]]:

    player_race = rpl.player[pid].play_race


    # In this function the intervals count the units from the begining of
    # the match to the end of the interval.
    interval_marks = [rpl.length.seconds,
                      INTERVALS_BASE,
                      INTERVALS_BASE*2,
                      rpl.length.seconds]

    # The units_df contains all the units owned by player (pid) in a
    # replay (rpl), with their birth and death times
    units_df = composition_df(rpl, pid, buildings=buildings)

    # Based on the interval_marks I devide and list the units_df into the
    # corresponding sub-dataframes
    dfs = [units_df.loc[units_df.started_building <= mark]
           for mark in interval_marks]

    # I use the count_active_units function to calculate the unit counts
    # and extract the totals for the different intervals
    compositions = [count_active_units(data, interval_mark)['total']
                    for interval_mark, data in zip(interval_marks, dfs)]


    # I use the compositions to generate four dictionaries with the full
    # army count which includes all possible units of all possible races.
    fin_dict = complete_count(compositions, player_race, buildings)


    return fin_dict



# Cell
def count_started(rpl: sc2reader.resources.Replay,
                  pid: int, buildings:bool =False) \
                  -> list[dict[str, int]]:

    player_race = rpl.player[pid].play_race
    # In this function the intervals count the units from the begining of
    # the interval to the end of the interval.
    interval_marks = [(0, rpl.length.seconds),
                      (0, INTERVALS_BASE),
                      (INTERVALS_BASE, INTERVALS_BASE*2),
                      (INTERVALS_BASE*2, rpl.length.seconds)]

    # The units_df contains all the units owned by player (pid) in a
    # replay (rpl), with their birth and death times
    units_df = composition_df(rpl, pid, buildings=buildings)

    #
    army_counts = [count_active_units(units_df,
                                      start= inter_start,
                                      end=inter_end)['started']
                   for inter_start, inter_end in interval_marks]

    return complete_count(army_counts, player_race, buildings)



# Cell
def get_expansion_time(rpl: sc2reader.resources.Replay,
                        pid: int) -> dict[str, float]:
    """Gets a dictionary with the finished_at times for a player's first
    three expansions.

    The functions searches a player's list of buildings and extracts the
    times (in seconds) when the first three base buildings are finished.
    These times are indexed as expan_1, expan_2 and expan_3.

    If the player had less than three expansions during the game the
    missing values are filled with np.nan. If they have more than 3
    expansions, the rest of the expansions are ignored.

    *Args*
        - rpl (sc2reader.resources.Replay)
                Replay containing the data of the match.
        - pid (int)
                Player id during the match.

    *Returns*
        - dict[str, float]
                Dictionary containing the names and completion times of the
                player's first three expansions.
    """
    max_expan = 4
    bases = {'Protoss': ['nexus'],
            'Zerg': ['hatchery', 'lair', 'hive'],
            'Terran':['commandcenter']}

    expansions = (f'expan_{num}' for num in range(1,max_expan))
    player_race = rpl.player[pid].play_race

    units_df = composition_df(rpl, pid, buildings=True)


    bases_df = units_df.loc[units_df['Unit'].isin(bases[player_race])
                            & units_df['enter_game_time'].notna()
                            & units_df['enter_game_time'] != 0]

    if max_expan >= len(bases_df):
        return {expan: u
                for expan, u
                in zip_longest(expansions,
                               bases_df.enter_game_time,
                               fillvalue= np.nan)}
    else:
        return {expan: u
                for expan, u
                in zip(expansions,
                       bases_df.enter_game_time)}


# Cell
def list_player_upgrades(rpl: sc2reader.resources.Replay,
                         pid: int) -> dict[str, float]:
    """Lists the times at wich the player completed their updates
    """
    player_race = rpl.player[pid].play_race

    upg_events = {upg_event.upgrade_type_name
        : calc_realtime_index(upg_event.second, rpl)
        for upg_event in rpl.events
        if isinstance(upg_event, sc2reader.events.tracker.UpgradeCompleteEvent)
        and upg_event.pid == pid
        and upg_event.upgrade_type_name in race_upgrades[player_race]}

    return {upgrade_name: upg_events.get(upgrade_name, 0)
            for upgrade_name in race_upgrades[player_race]}

