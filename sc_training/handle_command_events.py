# AUTOGENERATED! DO NOT EDIT! File to edit: 05_handle_command_events.ipynb (unless otherwise specified).

__all__ = ['calc_spe_abil_ratios', 'get_prefered_spec_abil', 'calc_attack_ratio']

# Internal Cell

# Load Module's dependencies
from pathlib import Path
from pprint import pprint
from typing import *
from itertools import zip_longest

import json
import pandas as pd
import fastcore.test as ft


# Internal Cell
import sc2reader
from sc2reader.engine.plugins import SelectionTracker, APMTracker
sc2reader.engine.register_plugin(SelectionTracker())
sc2reader.engine.register_plugin(APMTracker())

from .handle_tracker_event import *
from .macro_econ_parser import *

# Internal Cell
#Internal constants
data_path = (Path(Path.cwd()/'data')
             if Path('data').exists() else Path('../data'))

with open(data_path/'ability_list.json') as af:
    ABILITIES = json.load(af)

COMMON_ABILITIES = ['Attack',
                    'Stop',
                    'HoldPosition',
                    'Patrol',
                    'RightClick']

MOVE_COMMAND = ['RightClick']

# Internal Cell

def build_commands_df(rpl: sc2reader.resources.Replay,
                events: list[sc2reader.events.game.GameEvent])-> pd.DataFrame:

    df_columns =  ['real_time', 'second', 'ability_name']

    commands_df = pd.DataFrame([[calc_realtime_index(com_e.second, rpl),
                            com_e.second,
                            com_e.ability_name]
                        for com_e in events], columns= df_columns)

    return commands_df

# Cell

def calc_spe_abil_ratios(rpl: sc2reader.resources.Replay, pid: int) \
                    -> list[float]:

    replay_lenght = rpl.length.seconds
    player_race = rpl.player[pid].play_race

    commands_list = [com_e for com_e in rpl.events
                if isinstance(com_e, sc2reader.events.game.CommandEvent)
                and com_e.player.pid == pid]

    abil_comm_list = [com_e for com_e in rpl.events
                    if isinstance(com_e, sc2reader.events.game.CommandEvent)
                    and com_e.player.pid == pid
                    and com_e.ability_name in ABILITIES[player_race]
                    and com_e.ability_name not in COMMON_ABILITIES]

    commands = build_commands_df(rpl, commands_list)
    abilities_commands = build_commands_df(rpl, abil_comm_list)

    commands_dfs = gen_interval_sub_dfs(replay_lenght, commands,
                                       ['real_time', 'ability_name'])
    abilities_dfs = gen_interval_sub_dfs(replay_lenght, abilities_commands,
                                        ['real_time', 'ability_name'])

    return [total_abilities / total_commands if total_commands != 0 else 0
            for total_abilities, total_commands
            in zip(map(len, abilities_dfs), map(len, commands_dfs))]

# Internal Cell

def get_top_abilities(abilities: pd.DataFrame) -> tuple[str,str]:
    prefered = None
    second = None

    ability_count = (abilities
                    .groupby('ability_name')
                    .size())

    ability_count.sort_values(ascending=False, inplace=True)

    if len(ability_count) > 0:
        prefered = ability_count.index[0]

    if len(ability_count) >= 2:
        second = ability_count.index[1]

    return prefered, second

# Cell

def get_prefered_spec_abil(rpl: sc2reader.resources.Replay,
                           pid: int) -> list[tuple[str, int]]:

    replay_lenght = rpl.length.seconds
    player_race = rpl.player[pid].play_race


    abil_comm_list = [com_e for com_e in rpl.events
                    if isinstance(com_e, sc2reader.events.game.CommandEvent)
                    and com_e.player.pid == pid
                    and com_e.ability_name in ABILITIES[player_race]
                    and com_e.ability_name not in COMMON_ABILITIES]

    abilities_commands = build_commands_df(rpl, abil_comm_list)

    abilities_dfs = gen_interval_sub_dfs(replay_lenght, abilities_commands,
                                        ['real_time', 'ability_name'])

    preferences = [get_top_abilities(df) for df in abilities_dfs]

    return preferences

# Cell

def calc_attack_ratio(rpl: sc2reader.resources.Replay, pid: int) -> list[float]:

    replay_lenght = rpl.length.seconds

    common_comms = [com_e for com_e in rpl.events
                if isinstance(com_e, sc2reader.events.game.CommandEvent)
                and com_e.player.pid == pid
                and not com_e.ability.is_build
                and com_e.ability.name in COMMON_ABILITIES
                and com_e.ability_name in COMMON_ABILITIES]

    attack_comms = [att for att in common_comms
                if att.ability.name == 'Attack']

    common_comms_dfs = build_commands_df(rpl, common_comms)
    attack_comms_dfs = build_commands_df(rpl, attack_comms)

    cc_subdf_list = gen_interval_sub_dfs(replay_lenght, common_comms_dfs,
                                        ['real_time', 'ability_name'])

    ca_subdf_list = gen_interval_sub_dfs(replay_lenght, attack_comms_dfs,
                                        ['real_time', 'ability_name'])

    return [len(att) / len(comm) if len(comm) != 0 else 0
            for att, comm
            in zip(ca_subdf_list, cc_subdf_list)]