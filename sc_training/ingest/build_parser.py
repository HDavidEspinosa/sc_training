# AUTOGENERATED! DO NOT EDIT! File to edit: 04_build_parser.ipynb (unless otherwise specified).

__all__ = ['count_composition', 'count_started', 'get_expan_times', 'get_expan_counts', 'list_player_upgrades']

# Internal Cell

# Import dependencies
from pathlib import Path
from pprint import pprint
from dataclasses import dataclass, astuple, field
from datetime import datetime
from typing import *
from fastcore import test as ft
from itertools import zip_longest

import pandas as pd
import numpy as np
import csv
import json

# Internal Cell

import sc2reader

from .handle_tracker_event import *
from .macro_econ_parser import *


# Internal Cell

# Load data files
if __name__ == "__main__":
    data_path = Path(Path.cwd()/'data')

else:
    data_path = (Path(Path(__file__)/'data')
            if Path(Path(__file__)/'data').exists()
            else Path(Path(__file__)/'../../../data'))

with open(data_path/'unit_names.csv') as f:
    file_reader = csv.reader(f)
    UNIT_NAMES = next(file_reader)

# with open(data_path/'changes_names.csv') as f:
#     file_reader = csv.reader(f)
#     change_names = next(file_reader)

with open(data_path/'army_list.json') as f:
    RACE_ARMIES = json.load(f)

with open(data_path/'buildings_list.json') as f:
    RACE_BUILDINGS = json.load(f)

with open(data_path/'upgrades.json') as f:
    RACE_UPGRADES = json.load(f)

BASES = {'Protoss': ['nexus'],
        'Zerg': ['hatchery', 'lair', 'hive'],
        'Terran':['commandcenter']}

# Internal Cell
def composition_df(rpl: sc2reader.resources.Replay,
                   pid: int, buildings:bool=False) -> pd.DataFrame:
    """Generates a DataFrame that stores the spawning information of each
    of a player's units

    This function lists all of the units owned by a player during a match.
    It also stores each unit's spawning_start, spawning_finish and death
    times. These times have been calculated to coincide with the match's
    duration.

    *Args*
        - rpl (sc2reader.resources.Replay)
            The match's replay object.
        - pid (int)
            The player's match id.
        - buildings (bool=False)
            Boolean indicating if the function should calculate the army or
            building units' DataFrame

    *Returns*
        - pd.DataFrame
            DataFrame with columns: Unit, started_building, enter_game_time,
            and died_time.

    """
    p_race = rpl.player[pid].play_race

    # Get the player's race list of army or building units.
    u_list = RACE_BUILDINGS[p_race] if buildings else RACE_ARMIES[p_race]

    # Get the player's units-list.
    player_units = [(uname, u, u.id) for u in rpl.player[pid].units
                    for uname in u_list
                    if uname in u.name.lower()
                    and (('hallucinated' not in u.__dict__)
                         or ('hallucinated' in u.__dict__
                             and u.hallucinated == False))
                    and u.is_building == buildings]

    player_units_df = pd.DataFrame({
        'Unit':[uname for uname, u, id in player_units],
        'Uname': [u.name for uname, u, id in player_units],
        'UnitID':[id for uname, u, id in player_units],
        'started_building':[calc_realtime_index((u.started_at/rpl.game_fps),
                                                rpl)
                            for uname, u, id in player_units],
        'enter_game_time': [calc_realtime_index((u.finished_at/rpl.game_fps),
                                                rpl)
                            if u.finished_at != None else pd.NaT
                            for uname, u, id in player_units],
        'died_time': [calc_realtime_index((u.died_at/rpl.game_fps), rpl)
                      if u.died_at != None else pd.NaT
                      for uname, u, id in player_units]
    })

    if p_race == 'Terran' and buildings:
        # Correct double count for tech labs
        player_units_df.drop_duplicates(subset='UnitID',
                                        keep='last',
                                        inplace=True)

        # Correct misslabeling of reactors
        player_units_df.loc[player_units_df['Uname'].\
            str.contains('TechLab'), 'Unit'] = 'techlab'
        player_units_df.loc[player_units_df['Uname'].\
            str.contains('Reactor'), 'Unit'] = 'reactor'



    # Generate and return the DataFrame with info from the units.
    return player_units_df.drop(['Uname', 'UnitID'], axis=1)

# Internal Cell
def count_active_units(df: pd.DataFrame,
                       end: float, start:float = 0) -> pd.DataFrame:
    """Generates a count of units started, born (completed), and died during a
    specific period.

    This function uses a player's units' spawning start and finishing times
    and their death times to count their active units during a specific
    period. This period is defined by start and end values in seconds

    *Args*
        - df (pd.DataFrame)
            DataFrame of a player's units' start and finish spawning,
            and death times (see `composition_df` function)
        - end (float)
            End of the period
        - start (float = 0)
            Start of the period, if not defined, the function assumes it
            should count from the begining of the match

    *Returns*
        - pd.DataFrame
            DataFrame with records for all of a player's units wich were
            started, born, and died during a specific period of time.

    """


    # Gets the titles of the relevant DataFrame columns. Ignores the index
    # and the 'Units' columns.
    column_headers = df.columns[1:]

    # Gets a list of Sub-DataFrames that eliminate the rows where each of
    # the relevant columns has na values.
    dfs_no_na = [df.dropna(subset=[col_header])
                 for col_header in column_headers]

    # Takes each of the sub-DataFrames and eliminates the values that fall
    # out of the time indexes that are counted (start and end)
    states_dfs = [(state_df.loc[(state_df[header] > start)
                  & (state_df[header] <= end)]
                  if not state_df.empty else state_df)
                  for header, state_df in zip(column_headers, dfs_no_na)]

    # Counts the number of units in each sub-DataFrame.
    # i.e. Counts how many of each unit type were started, born and died
    # duringh the time limits (start, end).
    count_frames = [state_df.groupby('Unit').size() for state_df in states_dfs]

    # Organises the final DataFrame with the unit counts for the time period.
    headers = ['started', 'born', 'died']
    result_dfs = pd.DataFrame({head: count_frame
                               for head, count_frame
                               in zip(headers, count_frames)})
    result_dfs['total'] = result_dfs['born'].subtract(result_dfs['died'],
                                                      fill_value = 0)
    return result_dfs

# Internal Cell
def complete_count(compositions:list[pd.DataFrame],
                   player_race:str,
                   buildings:bool = False) -> list[dict[str, int]]:
    """
    Generate a DataFrame of a players unit count including all possible
    units for a player's race, even those that a player did not use
    during a match.

    Expands a player's simple unit count DataFrames adding columns for
    all the units a player's race affords them. Having columns for all
    units makes averaging with the results of multiple matches eassier.

    *Args*
        - compositions (list[pd.DataFrame])
            List of DataFrames containing the players' unit counts or army
            composition for different game stages or intervals.
        - player_race (str)
            The game race with which the player played the current match.
            Needed to complete the list of units or structures.
        - buildings (bool = False)
            This flag indicates if the DataFrames being constructed are of
            a player's buildings or army units.

    *Returns*
        - list[dict[str, int]]
            List of dictionaries with all the player's race's units as keys
            and the number of each unit a player had during a match as values.

    """
    unit_list = RACE_ARMIES if not buildings else RACE_BUILDINGS
    return [{unit: int(compo[unit]) if (unit in compo)
            and not np.isnan(compo[unit]) else 0
            for unit in unit_list[player_race]}
            for compo in compositions]

# Cell
def count_composition(rpl: sc2reader.resources.Replay,
                      pid: int, buildings:bool=False) \
                      -> dict[str, dict[str, int]]:
    """Generate a tally of all of a player's active units at different
    stages of the match.

    The function returns a dictionary of with four keys ('whole_comp',
    'early_comp', 'mid_comp', 'late_comp') each of which refers to a
    dictionary that stores pairs of 'unit_type' : 'active_unit_type_count`.
    There are values for all player's race unit types, even if the player
    has no active units of some types.

    *Args*
        - rpl (sc2reader.resources.Replay)
            Replay being processed
        - pid (int)
            In-game id for the player being analysed.
        - buildings (bool)=False
            Flag indicating if the function should count buildings (True)
            or troops (False)

    *Returns*
        - dict
            Tally of a player's active units during a match
    """

    player_race = rpl.player[pid].play_race


    # In this function the intervals count the units from the begining of
    # the match to the end of the interval.
    interval_marks = [rpl.length.seconds,
                      INTERVALS_BASE,
                      INTERVALS_BASE*2,
                      rpl.length.seconds]

    # The units_df contains all the units owned by player (pid) in a
    # replay (rpl), with their birth and death times
    units_df = composition_df(rpl, pid, buildings=buildings)

    # Based on the interval_marks I devide and list the units_df into the
    # corresponding sub-dataframes
    dfs = [units_df.loc[units_df.started_building <= mark]
           for mark in interval_marks]

    # I use the count_active_units function to calculate the unit counts
    # and extract the totals for the different intervals
    compositions = [count_active_units(data, interval_mark)['total']
                    for interval_mark, data in zip(interval_marks, dfs)]


    # I use the compositions to generate four dictionaries with the full
    # army count which includes all possible units of all possible races.
    fin_dict = complete_count(compositions, player_race, buildings)

    indexes=['whole_comp', 'early_comp', 'mid_comp', 'late_comp']
    return {name: comp for name, comp in zip(indexes,fin_dict)}

# Cell
def count_started(rpl: sc2reader.resources.Replay,
                  pid: int, buildings:bool =False) \
                  -> list[dict[str, int]]:
    """Generate a tally of all of a player's started units at different
    stages of the match.

    The function returns a dictionary of with four keys ('whole_started',
    'early_started', 'mid_started', 'late_started') each of which refers
    to a dictionary that stores pairs of 'unit_type' :
    'started_unit_type_count`. There are values for all player's race unit
    types, even if the player has no units of some types.

    *Args*
        - rpl (sc2reader.resources.Replay)
            Replay being processed
        - pid (int)
            In-game id for the player being analysed.
        - buildings (bool)=False
            Flag indicating if the function should count buildings (True)
            or troops (False)

    *Returns*
        dict
            Tally of a player's started units during a match

    """
    player_race = rpl.player[pid].play_race
    # In this function the intervals count the units from the begining of
    # the interval to the end of the interval.
    interval_marks = [(0, rpl.length.seconds),
                      (0, INTERVALS_BASE),
                      (INTERVALS_BASE, INTERVALS_BASE*2),
                      (INTERVALS_BASE*2, rpl.length.seconds)]

    # The units_df contains all the units owned by player (pid) in a
    # replay (rpl), with their birth and death times
    units_df = composition_df(rpl, pid, buildings=buildings)

    #
    army_counts = [count_active_units(units_df,
                                      start= inter_start,
                                      end=inter_end)['started']
                   for inter_start, inter_end in interval_marks]

    indexes = ['whole_started',
               'early_started',
               'mid_started',
               'late_started']

    fin_dict = complete_count(army_counts, player_race, buildings)

    return {name: comp for name, comp in zip(indexes,fin_dict)}

# Cell
def get_expan_times(rpl: sc2reader.resources.Replay,
                        pid: int) -> dict[str, float]:
    """Gets a dictionary with the finished_at times for a player's first
    three expansions.

    The functions searches a player's list of buildings and extracts the
    times (in seconds) when the first three base buildings are finished.
    These times are indexed as expan_1, expan_2 and expan_3.

    If the player had less than three expansions during the game the
    missing values are filled with np.nan. If they have more than 3
    expansions, the rest of the expansions are ignored.

    *Args*
        - rpl (sc2reader.resources.Replay)
                Replay containing the data of the match.
        - pid (int)
                Player id during the match.

    *Returns*
        - dict[str, float]
                Dictionary containing the names and completion times of the
                player's first three expansions.
    """
    max_expan = 4
    expansions = (f'expan_{num}' for num in range(1,max_expan))

    units_df = composition_df(rpl, pid, buildings=True)


    bases_df = units_df.loc[units_df['Unit'].isin(BASES[rpl.
                                                        player[pid].
                                                        play_race])
                            & units_df['enter_game_time'].notna()
                            & units_df['enter_game_time'] != 0]

    if (max_expan - 1) < len(bases_df):

        return {expan: u
                for expan, u
                in zip(expansions,
                       bases_df.enter_game_time.iloc[:2])}

    else:
        return {expan: u
                for expan, u
                in zip_longest(expansions,
                               bases_df.enter_game_time,
                               fillvalue= np.nan)}

# Cell
def get_expan_counts(rpl: sc2reader.resources.Replay,
                        pid: int) -> dict[str, int]:
    '''The function counts the number of base structures a player built
    at each game stage.

    *Args*
        - rpl (sc2reader.resources.Replay)
            Replay containing a match's information.
        - pid (int)
            The match player ID for the player being consider in the
            analysis.

    *Returns*
        - dict[str, int]
            Dictionary containing the base count for the whole, early,
            mid and late stages of the game.

    '''

    units_df = composition_df(rpl, pid, buildings=True)
    units_df['real_time'] = units_df['enter_game_time']

    interval_units_dfs = gen_interval_sub_dfs(rpl.length.seconds,
                                              units_df,
                                              ['Unit','enter_game_time'])

    expansion_count_names  = ['total_expan',
                              'earlyg_expan',
                              'midg_expan',
                              'lateg_expan']

    expansion_counts = dict()
    for in_name, in_df in zip(expansion_count_names, interval_units_dfs):
        interval_df = in_df.loc[units_df['Unit'].isin(BASES[rpl.
                                                        player[pid].
                                                        play_race])
                                & units_df['enter_game_time'].ne(0)]

        expansion_counts[in_name] = len(interval_df)


    return expansion_counts


# Cell
def list_player_upgrades(rpl: sc2reader.resources.Replay,
                         pid: int) -> dict[str, float]:
    """Lists the times at wich the player completed their updates
    """
    player_race = rpl.player[pid].play_race

    upg_events = {upg_event.upgrade_type_name
        : calc_realtime_index(upg_event.second, rpl)
        for upg_event in rpl.events
        if isinstance(upg_event, sc2reader.events.tracker.UpgradeCompleteEvent)
        and upg_event.pid == pid
        and upg_event.upgrade_type_name in RACE_UPGRADES[player_race]}

    return {upgrade_name: upg_events.get(upgrade_name, 0)
            for upgrade_name in RACE_UPGRADES[player_race]}